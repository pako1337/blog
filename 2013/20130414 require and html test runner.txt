Last time I've shown how to configure everything so that multiple files can easily be used to separate classes and how tests can include all required code by taking advantage of `jasmine-node` and `nodeJs` test runner. We left it with test running fine but noting that this will not work for `html` test runner. Let's see how it should be configured to check if I was right

First thing we will need will be `jasmine` code to make it all work - obviously. We can get it for free (awsome `MIT` license) from github: <a href="https://github.com/pivotal/jasmine/downloads" title="jasmine downloads">jasmine downloads</a> (if it is not working go to main project page <a href="https://github.com/pivotal/jasmine" title="jasmine">jasmine</a> and try to find where they moved download page). I've downloaded latest version available (1.3.1 at the time of writting this post) and unpacked it in my `./spec` directory. This zip file contained required `javascript` code to run the tests as well as `SpecRunner.html` file with preconfigured file and dependencies for fast and easy runnig specifications. There were also included some example specs and source codes but I've removed those as not needed.

When opening `SpecRunner.html` file we can see that it's just an ordinary `html` file with included styles and javascript - `jQuery` and `jasmine` so that everything is working and looking nice. There are also example of specifications and source code inclusions - but I've removed those since I've removed sample files, like said before. Closer to the bottom we can also see `javascript` function. I did not read it in details but it creates some test runner, configures it and fires it - all the details are in `jasmine.js` file.


Seeing two sections - one for source files and the other for specifications - I've added references to my files I wish to run in this test runner.
[gist]https://gist.github.com/pako1337/5382473[/gist]
As you can see those references lead to `lib` directory - it is output directory for my compiled files (which I compiled simply by calling `coffee --output .\lib --compile .`). Suppose that you do nothing more and just open the file in web browser - it should run all specs included. Try that and see.
I did and I got empty page and few `javascript` errors - `require is not defined`. Sure it's not - it is `nodeJs` function not present in `jasmine` by default. And we do use it in our specifications and classes. More - even if this method was defined it probably would not work as we hope it would - `exports` class would also not be defined as we use `window` object to pass references to our classes when running outside `nodeJs` (see previous blog).

But think about that for a second - what's the point of using `require` function in first place? To include other files. But we already included them in `html` definition so they are ready to use. We've taken care of `exports` object not being defined also by using `window` object. Solution to the problem seems pretty easy - write simple require function that will return reference to `window` object and rest of the code can stay unchanged. So I did - added this little snippet below `jasmine` references in runner file:
[gist]https://gist.github.com/pako1337/5382499[/gist]
Why does it work? Because `javascript` is dynamic language that tries to fit whatever it can wherever it can. You call `require` function - cool I have one, I will run it! It does not even care that function signature does not match - apparently it does not need all those arguments you've provided so why bother. Return value type is different (`window` is for sure different class than `exports`) - not a problem, I don't care - it says - I just hope you know what you're doing. And we sure know - just accessing properties that we've attached ourselves to the object. We'll be fine.

Running the `SpecRunner.html` file in web browser again shows us report from test running - all specifications passing (hopefully!) and everything is green. Cool!

And that's why dynamic languages are so fun - no need to worry about interfaces, types and everything else when all you need to do is some small hack to make some libraries work in different environments. Pretty clean hack I think in this case. Of course including to many of those is not a good idea. One still needs to follow good practices of development process. But that's not the point. The point is when you need to do something simple - it is exactly this - simple! All script languages should be like this - and not some weird `C` implementations with all kind if limitations and stuff you need to worry about

So that one was simple. I think my code files organization needs some small update for better looking references - but that's simple. I'm just happy to see everything running OK with so little work required. We will see what's further on the road. 'till next time!